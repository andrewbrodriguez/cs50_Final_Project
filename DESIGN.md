Front End:

The website design was primarily achieved using HTML and CSS. Across the entire website, I tried to maintain consistency in using navy blue as part of the color scheme, though there are notable exceptions such as the apology page where the text is made to match our apology image. Moreover, the text is most often set to a cursive font to capture the fairytale feeling that our website’s content emulates. 

All these stylistic designs, of course, are achieved through the use of CSS in the stylesheet, and in select cases, within the HTML page (particularly if we want some stylesheet attributes but also would like to differ the selected element from the stylesheet choices in a few specific manners).  

As for the design achieved by HTML, one such is the layout makes use of a navbar which we achieved through bootstrap. This allows the user to easily navigate our website: clicking the website logo on the left takes you to the homepage and the other sections on the right hand side of the navbar navigate you to the pages that correspond to their names. 

On the input page, our textbox can be resized by the user by dragging it with their mouse, and the text wraps within it. This more easily allows the user to view their input, which is particularly useful in situations where the user is writing directly into the textbox and not pasting into it. 

On the results page, additionally, the text box is made to match the size of the image next to it. In cases that the text overflows that box, a scroll bar is present which allows the user to scroll vertically in the text box and view the entirety of their text. As far as the gifs in our website go, we included them to keep our users company and hopefully spread a few laughs along the way!


Flask Features:

The Flask code is rooted in app.py and helpers.py. In app.py, we first configure the app, then we configure the CS50 library to use our SQLite database users.db, which stores user ids, usernames, hashes of passwords, data and time the user joined, and number of times they have run the story generator. The passwords that are inputted by the users – that already contain a number and a special character for an added level of security – are hashed by the generate_password_hash function from the werkzeug.security library. Upon future login, the check_password_hash function from the same library is used to determine if the password is a match. We did not store the password as plaintext for security purposes. The table users.db contains the headings id, username, hash, time, and num_runs. We then configure session management in our Flask application, specifying the session's lifespan, storage mechanism (filesystem), and enabling the use of sessions within the application. 

Then, we routed our app to our various HTML templates: index, input, results, login, logout, register, and stats. The functions that involve a user inputting a story to the textbox, viewing results, or viewing user statistic information, are decorated with the @login_required tag, which is defined in helpers.py using the wraps function from the functools library. 

The website is created such that the navbar will not contain routes to pages that require login until login has occurred, and the results tab is never visible from the navbar. The results page is only visible once the user has inputted their story and the images have been generated. Our python code within each function is thoroughly commented and strictly corresponds to the webpage for which it is contained. 


Back End: 

The back end for this website uses two APIs, Dalle 2 and ChatGPT 3.5. When a user inputs a story it is ingested via a function called ingest. This function splits the story into 10 roughly equal sized text blocks based upon number of senetences. Once ingested these blocks are then run through a prompt generator. This function makes a ChatGPT API call and for each block of text asks GPT to describe the visual scenary occuring in that block of text in a singular sentence. The prompt also notes to GPT to make sure that the prompt which GPT spits out is not violent and therefore will be valid to input into the image generator later. This process is not perfect however and we have error catches later down the line to that end.

Next the prompts generated by the prompt generator are input into an image generator. Each prompt is run through dalle 2 using a try except statement. The prompt generator tries to create a 512x512 pixel image fitting that prompt. Should this complete, the API will return a response which has a link to the image in it. Then using requests we save this image to a local directory in static titled images. These images are number to match the block for which they correpsond for later pairing. If the try statement fails, then the except will save an error image to the images folder for that block stating that that particular block may have violent content in it. We made the choice to only generate 10 images per story due to limits created by OpenAI. One of the issues we encountered was that the base level paid OpenAI account is only allowed 10 images generated per minute. As a result requests containing more than 10 images would need to be intentionally slowed as to not throw errors. 